---
phase: 03-authz-rate-limit
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/bansho/middleware/rate_limit.py
  - src/bansho/ratelimit/limiter.py
  - src/bansho/ratelimit/__init__.py
  - tests/test_rate_limit.py
autonomous: true

must_haves:
  truths:
    - "Requests are rate limited per API key"
    - "Requests are rate limited per tool"
    - "Limit exceeded returns 429"
  artifacts:
    - path: "src/bansho/ratelimit/limiter.py"
      provides: "Redis-backed limiter"
    - path: "src/bansho/middleware/rate_limit.py"
      provides: "Middleware enforcing limits"
  key_links:
    - from: "src/bansho/middleware/rate_limit.py"
      to: "src/bansho/storage/redis.py"
      via: "Redis operations"
      pattern: "REDIS_URL"
---

<objective>
Implement Redis-backed rate limiting per API key and per tool, driven by the policy file.

Purpose: Prevent abuse and demonstrate meaningful security controls in the demo (RATE-01..04).
Output: Limiter + middleware + tests.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-authz-rate-limit/03-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Redis-backed rate limiter primitive</name>
  <files>src/bansho/ratelimit/limiter.py
src/bansho/ratelimit/__init__.py</files>
  <action>
Implement a simple fixed-window limiter (MVP-safe):
- Keys:
  - per-api-key: `rl:{api_key_id}:{window}`
  - per-tool: `rl:{api_key_id}:{tool_name}:{window}`
- Use atomic Lua script in Redis to `INCR` and set `EXPIRE` on first hit.
- Return `{allowed: bool, remaining: int, reset_s: int}` for logging.
  </action>
  <verify>uv run pytest -q tests/test_rate_limit.py</verify>
  <done>Limiter is deterministic and tested without flakiness.</done>
</task>

<task type="auto">
  <name>Task 2: Add policy-driven rate limit middleware</name>
  <files>src/bansho/middleware/rate_limit.py</files>
  <action>
Create `enforce_rate_limit(policy, auth_ctx, tool_name)`:
- Read default per-key limit and per-tool overrides from policy.
- Enforce both limits (deny if either exceeded).
- Return 429 on exceed.
- Safe defaults: if policy missing rate limit config, apply conservative global default rather than disabling limits.
  </action>
  <verify>uv run python -c "print('rate limit middleware imports')"</verify>
  <done>Rate limiting middleware exists and uses Redis-backed limiter.</done>
</task>

<task type="auto">
  <name>Task 3: Rate limiting tests (429)</name>
  <files>tests/test_rate_limit.py</files>
  <action>
Add tests:
- Configure policy with very low limits (e.g., 2 per 10s) for a tool.
- Call tool repeatedly and assert 429 when exceeded.
- Test both per-key and per-tool dimensions.
  </action>
  <verify>uv run pytest -q</verify>
  <done>Tests prove 429 behavior and limit reset semantics.</done>
</task>

</tasks>

<verification>
- `uv run pytest -q` passes
</verification>

<success_criteria>
- Rate limits are enforced per API key and per tool based on YAML configuration.
</success_criteria>

<output>
After completion, create `.planning/phases/03-authz-rate-limit/03-03-SUMMARY.md`
</output>
