---
phase: 05-demo-submit
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - demo/run_before_after.sh
  - demo/policies_demo.yaml
  - demo/README.md
autonomous: true

must_haves:
  truths:
    - "A single script can run the before/after demo end-to-end"
    - "After state demonstrates 401, 403, 429, and audit logging"
  artifacts:
    - path: "demo/run_before_after.sh"
      provides: "Deterministic demo runner"
    - path: "demo/policies_demo.yaml"
      provides: "Demo policy configuration"
  key_links:
    - from: "demo/run_before_after.sh"
      to: "src/mcp_sentinel/main.py"
      via: "start sentinel"
      pattern: "mcp_sentinel serve"
---

<objective>
Create a deterministic "before/after" demo runner that shows authentication, authorization, rate limiting, and audit logging.

Purpose: Make the hackathon recording fast, repeatable, and compelling.
Output: Demo script + demo policy.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-demo-submit/05-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add demo policy file tuned for the recording</name>
  <files>demo/policies_demo.yaml</files>
  <action>
Create a demo-focused policy file:
- Allow only a harmless tool for `readonly`.
- Reserve sensitive tool for `admin` only.
- Configure low rate limit for one tool to reliably trigger 429.
Keep it separate from `config/policies.yaml` so the main defaults remain safe.
  </action>
  <verify>uv run python -c "from mcp_sentinel.policy.loader import load_policy; load_policy('demo/policies_demo.yaml'); print('loaded')"</verify>
  <done>Demo policy loads and has a clear allow/deny + rate limit story.</done>
</task>

<task type="auto">
  <name>Task 2: Create a before/after runner script</name>
  <files>demo/run_before_after.sh
demo/README.md</files>
  <action>
Create a single script that:
- Starts docker services if needed (use the repo's `docker-compose.yml`):
  - From repo root (or by referencing the compose file explicitly), run:
    - `docker compose -f docker-compose.yml up -d redis postgres`
  - Add a basic readiness loop with a timeout (e.g., 60s) that checks:
    - `docker compose -f docker-compose.yml exec -T redis redis-cli --raw ping` returns `PONG`
    - `docker compose -f docker-compose.yml exec -T postgres pg_isready -h 127.0.0.1 -U sentinel -d mcp_sentinel` returns success
  - If readiness fails, print `docker compose -f docker-compose.yml ps` and exit non-zero.
- Cleanup expectations:
  - Always tear down any processes started by this script (vulnerable server, sentinel process) via `trap` on EXIT.
  - Do NOT destroy docker volumes (no `down -v`). It is acceptable to leave docker services running after the script completes.
- Runs the vulnerable server + attack script (before).
- Starts Sentinel pointing at the vulnerable server as upstream.
- Uses the demo policy by setting `SENTINEL_POLICY_PATH=demo/policies_demo.yaml` (do not modify `config/policies.yaml` for the recording).
- Demonstrates:
  - 401 without API key
  - 403 with key lacking permission
  - 429 by exceeding the configured limit
  - Successful call with correct key
  - Dashboard shows audit events (or prints audit count from DB)
Script should exit non-zero on unexpected results.
  </action>
  <verify>bash demo/run_before_after.sh</verify>
  <done>One command runs a deterministic before/after demo with clear terminal output and uses `demo/policies_demo.yaml` via `SENTINEL_POLICY_PATH`.</done>
</task>

</tasks>

<verification>
- Run the demo script twice; results are stable and easy to narrate
</verification>

<success_criteria>
- Demo runner showcases all MVP security controls in under 2 minutes.
</success_criteria>

<output>
After completion, create `.planning/phases/05-demo-submit/05-02-SUMMARY.md`
</output>
