---
phase: 05-demo-submit
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - demo/run_before_after.sh
  - demo/policies_demo.yaml
  - demo/README.md
autonomous: true

must_haves:
  truths:
    - "A single script can run the before/after demo end-to-end"
    - "After state demonstrates 401, 403, 429, and audit logging"
    - "Demo runner provisions admin and readonly API keys for the after scenario"
  artifacts:
    - path: "demo/run_before_after.sh"
      provides: "Deterministic demo runner"
    - path: "demo/policies_demo.yaml"
      provides: "Demo policy configuration"
  key_links:
    - from: "demo/run_before_after.sh"
      to: "src/bansho/main.py"
      via: "start sentinel"
      pattern: "bansho serve"
---

<objective>
Create a deterministic "before/after" demo runner that shows authentication, authorization, rate limiting, and audit logging.

Purpose: Make the hackathon recording fast, repeatable, and compelling.
Output: Demo script + demo policy.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-demo-submit/05-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add demo policy file tuned for the recording</name>
  <files>demo/policies_demo.yaml</files>
  <action>
Create a demo-focused policy file:
- Allow only a harmless tool for `readonly`.
- Reserve sensitive tool for `admin` only.
- Configure low rate limit for one tool to reliably trigger 429.
Keep it separate from `config/policies.yaml` so the main defaults remain safe.
  </action>
  <verify>uv run python -c "import yaml; d=yaml.safe_load(open('demo/policies_demo.yaml')); assert isinstance(d, dict) and 'roles' in d and 'rate_limits' in d; print('loaded')"</verify>
  <done>Demo policy loads and has a clear allow/deny + rate limit story.</done>
</task>

<task type="auto">
  <name>Task 2: Create a before/after runner script</name>
  <files>demo/run_before_after.sh
demo/README.md</files>
  <action>
Create a single script that:
- Starts docker services if needed (use the repo's `docker-compose.yml`):
  - From repo root (or by referencing the compose file explicitly), run:
    - `docker compose -f docker-compose.yml up -d redis postgres`
  - Add a basic readiness loop with a timeout (e.g., 60s) that checks:
    - `docker compose -f docker-compose.yml exec -T redis redis-cli --raw ping` returns `PONG`
    - `docker compose -f docker-compose.yml exec -T postgres pg_isready -h 127.0.0.1 -U bansho -d bansho` returns success
  - If readiness fails, print `docker compose -f docker-compose.yml ps` and exit non-zero.
- Cleanup expectations:
  - Always tear down any processes started by this script (vulnerable server, sentinel process) via `trap` on EXIT.
  - Do NOT destroy docker volumes (no `down -v`). It is acceptable to leave docker services running after the script completes.
- Runs the vulnerable server + attack script (before).
- Deterministically provision demo API keys (so the demo works on a clean machine):
  - Create a `readonly` key and an `admin` key using the existing CLI (keys are stored in Postgres):
    - `uv run bansho keys create --role readonly`
    - `uv run bansho keys create --role admin`
  - Capture the printed `api_key:` values into env vars (example naming):
    - `DEMO_READONLY_API_KEY` (used for 403 + 429)
    - `DEMO_ADMIN_API_KEY` (used for the successful sensitive call)
  - The script must fail fast if either key is missing/blank.
- Starts Sentinel as an MCP stdio server, configured as a proxy to the vulnerable server (stdio upstream):
  - Pin the exact sentinel invocation used by the script:
    - command: `uv`
    - args: `run bansho serve`
  - Provide env to the Sentinel process (and print them once at start for debugging):
    - `UPSTREAM_TRANSPORT=stdio`
    - `UPSTREAM_CMD="uv run python demo/vulnerable_server.py"`
    - `BANSHO_POLICY_PATH=demo/policies_demo.yaml`
    - optionally set `POSTGRES_DSN` / `REDIS_URL` only if you need to override defaults

- Demonstrates the after-state enforcement (assert and print each outcome):
  - 401: Call a harmless tool with NO API key and assert `McpError.error.code == 401`.
  - 403: Call the sensitive tool with `DEMO_READONLY_API_KEY` and assert code 403.
  - 429: Call a rate-limited tool twice quickly with `DEMO_READONLY_API_KEY` (first succeeds, second raises code 429).
  - 200: Call the sensitive tool with `DEMO_ADMIN_API_KEY` and assert success (no error).

  Implement these calls by talking to Sentinel over stdio using the same pattern as `tests/test_passthrough.py`:
  - `mcp.client.stdio.StdioServerParameters(..., env={...})` + `stdio_client(...)` + `ClientSession(...)`
  - Pass API keys via MCP request meta headers:
    - `auth_meta = types.RequestParams.Meta.model_validate({"headers": {"X-API-Key": "..."}})`

- Audit evidence (required):
  - Assert audit count increases (DB-level proof):
    - Capture audit count before and after the after-scenario tool calls, and assert it increased (delta >= 1).
    - Table name is `audit_events` (see `src/bansho/ui/dashboard.py`).
    - Suggested query (inside the postgres container):
      - `docker compose -f docker-compose.yml exec -T postgres env PGPASSWORD=bansho psql -U bansho -d bansho -tAc "SELECT count(*) FROM audit_events;"`

  - Show audit evidence via the dashboard API (judge-friendly proof):
    - Start dashboard in the background: `uv run bansho dashboard`
    - Fetch events and assert non-empty:
      - `curl -s -H "X-API-Key: ${DEMO_ADMIN_API_KEY}" "http://127.0.0.1:9100/api/events?limit=5"`

Script should exit non-zero on unexpected results.
  </action>
  <verify>bash demo/run_before_after.sh</verify>
  <done>One command runs a deterministic before/after demo with clear terminal output and uses `demo/policies_demo.yaml` via `BANSHO_POLICY_PATH`.</done>
</task>

</tasks>

<verification>
- Run the demo script twice; results are stable and easy to narrate
</verification>

<success_criteria>
- Demo runner showcases all MVP security controls in under 2 minutes.
</success_criteria>

<output>
After completion, create `.planning/phases/05-demo-submit/05-02-SUMMARY.md`
</output>
