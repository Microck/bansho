---
phase: 05-demo-submit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - demo/vulnerable_server.py
  - demo/client_attack.py
  - demo/README.md
autonomous: true

must_haves:
  truths:
    - "A vulnerable MCP server exists that allows tool execution without auth"
    - "A demo client can call a sensitive tool against the vulnerable server"
  artifacts:
    - path: "demo/vulnerable_server.py"
      provides: "Unauthenticated MCP server"
    - path: "demo/client_attack.py"
      provides: "Client script demonstrating unauthorized access"
  key_links:
    - from: "demo/client_attack.py"
      to: "demo/vulnerable_server.py"
      via: "connect and call tool"
      pattern: "tools/call"
---

<objective>
Create a vulnerable MCP server and an attack client script to demonstrate the "before" state.

Purpose: Make the security improvement obvious in the hackathon demo.
Output: Demo server + attack script.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement vulnerable MCP server (no auth)</name>
  <files>demo/vulnerable_server.py</files>
  <action>
Create a small MCP server using the official `mcp` SDK:
- Expose 2-3 tools including one clearly "sensitive" one for demo (e.g., `delete_customer`, `wipe_cache`, etc.) that returns a fake but scary message.
- No auth, no rate limiting, no audit logging.
- Run locally over an easily proxied transport (stdio is fine).

To support reliable verification (without depending on Task 2 artifacts), add a self-contained CLI mode in `demo/vulnerable_server.py`:
- `--self-test`: prints the tool names it registers, then invokes the sensitive tool handler directly (in-process, not via MCP transport) and exits 0 only if:
  - the tool registry includes the expected tools (>=2 tools, includes the sensitive tool name), and
  - the sensitive tool returns a non-empty, clearly "scary" string.
- Exit non-zero with a clear error message if any expectation fails.

Also ensure the companion client script (Task 2) can connect to this server over stdio and list tools.
  </action>
  <verify>uv run python demo/vulnerable_server.py --self-test</verify>
  <done>`uv run python demo/vulnerable_server.py --self-test` exits 0 and the server exposes tools without requiring credentials.</done>
</task>

<task type="auto">
  <name>Task 2: Implement attack client demonstrating unauthorized tool call</name>
  <files>demo/client_attack.py</files>
  <action>
Create a demo client script:
- Spawn the vulnerable server as a subprocess over stdio (do NOT require a separately-running server).
  - Start command should be deterministic (e.g., `uv run python demo/vulnerable_server.py` with an explicit stdio/server mode flag if needed).
  - Capture/pipe stdio as required for the MCP client transport.
  - Always terminate the server on exit (success or failure). Use a `try/finally` or `atexit` handler; escalate to kill after a short timeout.
- Connect to the spawned server.
- List tools and call the sensitive tool without any credentials.
- Print clear output that will look good in a screen recording.

Add a smoke mode `--list-tools-only` that:
- Spawns the server subprocess, connects, prints the tool list, and then tears down the subprocess.
- Exits non-zero if no tools are returned.
- Exits non-zero if the server cannot be started or does not shut down cleanly.
  </action>
  <verify>uv run python demo/client_attack.py</verify>
  <done>Attack script successfully calls the sensitive tool against the vulnerable server.</done>
</task>

<task type="auto">
  <name>Task 3: Add demo README quickstart</name>
  <files>demo/README.md</files>
  <action>
Document exactly how to run the vulnerable demo locally:
- Commands to start the vulnerable server.
- Command to run the attack client.
- Expected output snippets.
  </action>
  <verify>rg -n "uv run python demo/vulnerable_server\.py|uv run python demo/client_attack\.py" demo/README.md</verify>
  <done>Demo README has copy/paste commands for the "before" scenario.</done>
</task>

</tasks>

<verification>
- Run the vulnerable server + attack script on a clean machine and confirm the output is deterministic
</verification>

<success_criteria>
- "Before" demo reliably shows unauthorized tool execution.
</success_criteria>

<output>
After completion, create `.planning/phases/05-demo-submit/05-01-SUMMARY.md`
</output>
