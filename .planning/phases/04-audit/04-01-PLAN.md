---
phase: 04-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bansho/audit/logger.py
  - src/bansho/audit/models.py
  - src/bansho/audit/__init__.py
  - tests/test_audit_logger.py
autonomous: true

must_haves:
  truths:
    - "Every tool request can be recorded with timestamp and client identity"
  artifacts:
    - path: "src/bansho/audit/logger.py"
      provides: "Audit event writer to Postgres"
    - path: "src/bansho/audit/models.py"
      provides: "Audit event schema"
  key_links:
    - from: "src/bansho/audit/logger.py"
      to: "src/bansho/storage/postgres.py"
      via: "INSERT audit_events"
      pattern: "INSERT INTO audit_events"
---

<objective>
Create audit logging primitives to persist request/response metadata to Postgres.

Purpose: Provide accountability and a demo-visible security outcome (AUDIT-01..03).
Output: Audit logger + tests.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-authz-rate-limit/03-04-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define audit event model</name>
  <files>src/bansho/audit/models.py
src/bansho/audit/__init__.py</files>
  <action>
Define an `AuditEvent` model:
- Fields: `ts`, `api_key_id`, `role`, `method`, `tool_name`, `request_json`, `response_json`, `status_code`, `latency_ms`, `decision` (auth/authz/rate info).
- Keep JSON payloads bounded (truncate large blobs to safe size; store only what is needed for demo).
  </action>
  <verify>uv run python -c "from bansho.audit.models import AuditEvent; print('ok')"</verify>
  <done>Audit model exists and is safe to serialize into Postgres JSONB.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Postgres audit logger</name>
  <files>src/bansho/audit/logger.py
tests/test_audit_logger.py</files>
  <action>
Implement `AuditLogger`:
- `log_event(event)` inserts into `audit_events`.
- Avoid logging secrets: never store plaintext API key.
- Tests: insert event and query back (or mock insert if DB unavailable in CI).
  </action>
  <verify>uv run pytest -q tests/test_audit_logger.py</verify>
  <done>Audit logger writes to Postgres and is covered by tests.</done>
</task>

</tasks>

<verification>
- `uv run pytest -q` passes
</verification>

<success_criteria>
- Audit logger can record tool invocations with identity + timestamp + outcome.
</success_criteria>

<output>
After completion, create `.planning/phases/04-audit/04-01-SUMMARY.md`
</output>
