---
phase: 04-audit
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/mcp_sentinel/proxy/sentinel_server.py
  - tests/test_audit_integration.py
autonomous: true

must_haves:
  truths:
    - "Every tool call attempt produces an audit event (allowed or denied)"
  artifacts:
    - path: "tests/test_audit_integration.py"
      provides: "Audit integration regression"
  key_links:
    - from: "src/mcp_sentinel/proxy/sentinel_server.py"
      to: "src/mcp_sentinel/audit/logger.py"
      via: "log after decision"
      pattern: "AuditLogger"
---

<objective>
Wire audit logging into the actual request pipeline so every request is recorded (including denials).

Purpose: Make audit behavior real and non-optional.
Output: Pipeline emits audit events + integration test.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-audit/04-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instrument proxy pipeline with audit events</name>
  <files>src/mcp_sentinel/proxy/sentinel_server.py</files>
  <action>
Update the request pipeline to always emit an audit event:
- Log on both allowed and denied outcomes.
- Include decision details (auth/authz/rate) and latency.
- For denied requests, response_json should include only safe error metadata.
- Ensure logging happens even when upstream fails (capture upstream error safely).
  </action>
  <verify>uv run pytest -q tests/test_audit_integration.py</verify>
  <done>Proxy emits one audit event per request attempt, regardless of outcome.</done>
</task>

<task type="auto">
  <name>Task 2: Integration test for audit coverage</name>
  <files>tests/test_audit_integration.py</files>
  <action>
Add a test that:
- Executes an unauthenticated request (expect 401) and asserts an audit row exists.
- Executes an authenticated-but-denied tool call (403) and asserts audit row exists.
- Executes an allowed tool call (200) and asserts audit row exists.
Use the test DB from docker compose.
  </action>
  <verify>uv run pytest -q</verify>
  <done>Audit rows exist for 401/403/200 cases.</done>
</task>

</tasks>

<verification>
- `uv run pytest -q` passes
</verification>

<success_criteria>
- Audit logging is comprehensive and includes denied requests.
</success_criteria>

<output>
After completion, create `.planning/phases/04-audit/04-02-SUMMARY.md`
</output>
