---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - uv.lock
  - src/mcp_sentinel/__init__.py
  - src/mcp_sentinel/config.py
  - src/mcp_sentinel/logging.py
  - src/mcp_sentinel/main.py
  - docker-compose.yml
  - .env.example
autonomous: true
user_setup:
  - service: local-docker
    why: "Run Redis + PostgreSQL for local dev"
    commands:
      - "docker compose up -d redis postgres"
    env_vars:
      - name: "POSTGRES_DSN"
        source: ".env (local)"
      - name: "REDIS_URL"
        source: ".env (local)"

must_haves:
  truths:
    - "App starts and reads configuration from environment"
    - "Local Redis + Postgres can be started via docker compose"
  artifacts:
    - path: "pyproject.toml"
      provides: "Python dependencies and tool config"
    - path: "src/mcp_sentinel/config.py"
      provides: "Typed settings (dsn/urls/upstream)"
    - path: "docker-compose.yml"
      provides: "Local Redis + Postgres services"
  key_links:
    - from: "src/mcp_sentinel/main.py"
      to: "src/mcp_sentinel/config.py"
      via: "settings load"
      pattern: "from mcp_sentinel\\.config import Settings"
---

<objective>
Initialize the Python project skeleton and local dev services so later phases can implement the MCP proxy and security features.

Purpose: Create a stable foundation (deps, config, logging, Docker) that every later phase builds on.
Output: Runnable app entrypoint + local Redis/Postgres via docker compose.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold project + dependencies</name>
  <files>pyproject.toml
uv.lock
src/mcp_sentinel/__init__.py
src/mcp_sentinel/main.py</files>
  <action>
Create a minimal Python package and entrypoint:
- Use `uv` + `pyproject.toml` with strict tooling: `ruff`, `pytest`, `mypy`.
- Add runtime deps needed for upcoming phases: `mcp` (official MCP Python SDK), `pydantic-settings`, `pyyaml`, `redis`, `asyncpg`, `httpx`, `structlog`.
- Add `python3 -m mcp_sentinel` entrypoint that only loads settings, configures logging, and exits with a clear message (no proxy logic yet).
- Keep it simple; no framework choices that constrain later work.
  </action>
  <verify>uv run python -m mcp_sentinel --help</verify>
  <done>Project installs/runs locally and prints usage/help without traceback.</done>
</task>

<task type="auto">
  <name>Task 2: Add typed config + logging baseline</name>
  <files>src/mcp_sentinel/config.py
src/mcp_sentinel/logging.py
.env.example</files>
  <action>
Implement configuration + logging primitives:
- `Settings` object reading: `SENTINEL_LISTEN_HOST`, `SENTINEL_LISTEN_PORT`, `UPSTREAM_TRANSPORT` (stdio|http), `UPSTREAM_CMD` (for stdio), `UPSTREAM_URL` (for http), `POSTGRES_DSN`, `REDIS_URL`.
- Default to safe values (bind to 127.0.0.1 by default; no broad 0.0.0.0 bind unless explicitly set).
- Add structured logging via `structlog` with request-id friendly format.
- Add `.env.example` with placeholders (no secrets).
  </action>
  <verify>uv run python -c "from mcp_sentinel.config import Settings; print(Settings().model_dump())"</verify>
  <done>Settings load from env without errors; logging module can be imported.</done>
</task>

<task type="auto">
  <name>Task 3: Add docker compose for Redis + Postgres</name>
  <files>docker-compose.yml</files>
  <action>
Add local-only `docker-compose.yml`:
- Services: `redis` and `postgres`.
- Expose ports on localhost only; include basic healthchecks.
- Postgres uses a dedicated database (e.g., `mcp_sentinel`) and persistent volume.
- Do NOT include application container yet.
  </action>
  <verify>docker compose up -d redis postgres && docker compose ps</verify>
  <done>Redis and Postgres containers start healthy on the configured ports.</done>
</task>

</tasks>

<verification>
- `uv run ruff check .` passes
- `uv run pytest` runs (even if zero tests initially)
</verification>

<success_criteria>
- A new contributor can start Redis/Postgres with a single docker compose command and run the app entrypoint.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
