---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/mcp_sentinel/proxy/upstream.py
  - src/mcp_sentinel/proxy/sentinel_server.py
  - src/mcp_sentinel/proxy/__init__.py
  - src/mcp_sentinel/main.py
  - tests/test_passthrough.py
autonomous: true

must_haves:
  truths:
    - "A client can connect to Sentinel and list tools from the upstream server"
    - "A client tool call is forwarded to the upstream server and returns the same result"
    - "A client can list/read resources and list/get prompts through Sentinel when the upstream supports them"
  artifacts:
    - path: "src/mcp_sentinel/proxy/sentinel_server.py"
      provides: "Sentinel acts as MCP server to clients"
    - path: "src/mcp_sentinel/proxy/upstream.py"
      provides: "Upstream MCP client connection"
    - path: "tests/test_passthrough.py"
      provides: "Passthrough regression test"
  key_links:
    - from: "src/mcp_sentinel/proxy/sentinel_server.py"
      to: "src/mcp_sentinel/proxy/upstream.py"
      via: "forward MCP request/response across method families"
      pattern: "(tools|resources|prompts)/(list|call|read|get)"
---

<objective>
Build a fully spec-compliant MCP passthrough where Sentinel presents an MCP server to clients and forwards requests to a configured upstream MCP server.

Purpose: Establish the core gateway behavior before adding auth/authz/rate limiting.
Output: Working passthrough proxy + test proving request forwarding.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement upstream connection abstraction</name>
  <files>src/mcp_sentinel/proxy/upstream.py
src/mcp_sentinel/proxy/__init__.py</files>
  <action>
Create an upstream connector using the official `mcp` Python SDK:
- Support `UPSTREAM_TRANSPORT=stdio` by spawning a subprocess from `UPSTREAM_CMD` and speaking MCP over stdio.
- Support `UPSTREAM_TRANSPORT=http` by connecting to `UPSTREAM_URL` using the SDK's HTTP transport.
- Expose async methods that Sentinel will use:
  - session lifecycle: `initialize()` (so Sentinel can reflect upstream capabilities)
  - tools: `list_tools()`, `call_tool(name, arguments)`
  - resources: `list_resources()`, `read_resource(uri)`
  - prompts: `list_prompts()`, `get_prompt(name, arguments)`
- Keep the surface small; this will make it easier to wrap with authz/rate limiting later.
  </action>
  <verify>
uv run python -m compileall src
uv run python -c "from mcp_sentinel.proxy.upstream import UpstreamConnector; print(UpstreamConnector)"
  </verify>
  <done>Upstream connector module exists with a stable API surface for tool listing and calling.</done>
</task>

<task type="auto">
  <name>Task 2: Sentinel MCP server that forwards tool methods</name>
  <files>src/mcp_sentinel/proxy/sentinel_server.py
src/mcp_sentinel/main.py</files>
  <action>
Implement Sentinel as an MCP server to clients:
- Use the `mcp` SDK server primitives to expose and forward the core MCP method families.
- Minimum forwarding surface ("spec-compliant" for this project):
  - session init: forward client initialize to upstream initialize; return upstream capabilities
  - tools: `tools/list`, `tools/call`
  - resources: `resources/list`, `resources/read`
  - prompts: `prompts/list`, `prompts/get`
- Forward upstream responses without reshaping payloads.
- Add a minimal health/log line on startup showing listen addr and upstream config.
  </action>
  <verify>uv run python -m mcp_sentinel</verify>
  <done>Running the app starts a server without crashing; forwarding handlers exist for tools/resources/prompts.</done>
</task>

<task type="auto">
  <name>Task 3: Passthrough test with a fake upstream server</name>
  <files>tests/test_passthrough.py</files>
  <action>
Add a regression test:
- Start a tiny in-process upstream MCP server (SDK-based) exposing:
  - a deterministic tool (e.g., `echo`)
  - a deterministic resource (e.g., `resource://hello.txt`)
  - a deterministic prompt (e.g., `summarize`) with fixed output
- Start Sentinel configured to connect to that upstream.
- Assert through Sentinel:
  - `tools/list` includes `echo`, and calling `echo` returns the upstream response verbatim
  - `resources/list` includes the test resource, and `resources/read` returns the upstream content verbatim
  - `prompts/list` includes the test prompt, and `prompts/get` returns the upstream content verbatim
  </action>
  <verify>uv run pytest -q</verify>
  <done>Test suite proves passthrough works end-to-end across tools/resources/prompts.</done>
</task>

</tasks>

<verification>
- `uv run pytest -q` passes
- Manual sanity: connect with an MCP client and verify tool listing works
</verification>

<success_criteria>
- Sentinel can proxy an MCP tool listing and tool call to an upstream server without modifying payloads.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
