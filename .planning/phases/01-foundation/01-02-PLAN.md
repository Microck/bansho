---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/bansho/storage/redis.py
  - src/bansho/storage/postgres.py
  - src/bansho/storage/schema.py
  - src/bansho/storage/__init__.py
autonomous: true

must_haves:
  truths:
    - "App can connect to Redis using REDIS_URL"
    - "App can connect to Postgres using POSTGRES_DSN"
    - "Database schema bootstrap can run idempotently"
  artifacts:
    - path: "src/bansho/storage/redis.py"
      provides: "Async Redis client wrapper"
    - path: "src/bansho/storage/postgres.py"
      provides: "Async Postgres pool wrapper"
    - path: "src/bansho/storage/schema.py"
      provides: "Schema bootstrap SQL (idempotent)"
  key_links:
    - from: "src/bansho/storage/postgres.py"
      to: "src/bansho/storage/schema.py"
      via: "ensure_schema()"
      pattern: "def ensure_schema\("
---

<objective>
Implement Redis + PostgreSQL access layers with idempotent schema bootstrap to support rate limiting, API keys, and audit logging in later phases.

Purpose: Make storage a solved problem early so security features can build on stable primitives.
Output: Storage clients + schema bootstrap.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Redis client wrapper</name>
  <files>src/bansho/storage/redis.py
src/bansho/storage/__init__.py</files>
  <action>
Create a tiny async Redis wrapper:
- Provide `get_redis()` factory reading `Settings.REDIS_URL`.
- Provide helpers that will be used by rate limiting (get/set/incr/expire, lua eval hook).
- Ensure proper connection cleanup (`aclose`).
  </action>
  <verify>uv run python -c "import asyncio; from bansho.storage.redis import ping_redis; asyncio.run(ping_redis())"</verify>
  <done>`ping_redis()` returns true against local docker Redis.</done>
</task>

<task type="auto">
  <name>Task 2: Postgres pool wrapper + schema bootstrap</name>
  <files>src/bansho/storage/postgres.py
src/bansho/storage/schema.py</files>
  <action>
Implement a Postgres pool and idempotent schema bootstrap:
- Use `asyncpg` pool with reasonable timeouts.
- Add `ensure_schema()` that creates tables needed for MVP (even if some are unused until later phases):
  - `api_keys` (id, key_hash, role, created_at, revoked_at)
  - `audit_events` (id, ts, api_key_id, method, tool_name, request_json, response_json, status_code, latency_ms)
- Use `CREATE TABLE IF NOT EXISTS` and safe types (`uuid`, `timestamptz`, `jsonb`).
  </action>
  <verify>uv run python -c "import asyncio; from bansho.storage.postgres import ensure_schema; asyncio.run(ensure_schema())"</verify>
  <done>Schema bootstrap runs twice without error and creates required tables.</done>
</task>

<task type="auto">
  <name>Task 3: Storage smoke test</name>
  <files>src/bansho/storage/schema.py</files>
  <action>
Add a lightweight smoke-test function (not a full test suite yet):
- `storage_smoke_check()` connects to both Redis + Postgres and returns a dict of booleans.
- This will be reused in CLI health checks later.
  </action>
  <verify>uv run python -c "import asyncio; from bansho.storage.schema import storage_smoke_check; print(asyncio.run(storage_smoke_check()))"</verify>
  <done>Smoke check prints `{redis: true, postgres: true}` when docker services are up.</done>
</task>

</tasks>

<verification>
- `docker compose ps` shows healthy redis/postgres
- `uv run ruff check .` passes
</verification>

<success_criteria>
- Redis + Postgres connectivity is reliable and schema bootstrap is idempotent.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
